/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, type Account, type Address, type EncodedAccount, type FetchAccountConfig, type FetchAccountsConfig, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type MaybeAccount, type MaybeEncodedAccount } from '@solana/kit';
import { getStatusDecoder, getStatusEncoder, type Status, type StatusArgs } from '../types';




export type Payment = { discriminator: number; orderId: number; amount: bigint; createdAt: bigint; status: Status; bump: number;  };

export type PaymentArgs = { discriminator: number; orderId: number; amount: number | bigint; createdAt: number | bigint; status: StatusArgs; bump: number;  };




export function getPaymentEncoder(): FixedSizeEncoder<PaymentArgs> {
  return getStructEncoder([['discriminator', getU8Encoder()], ['orderId', getU32Encoder()], ['amount', getU64Encoder()], ['createdAt', getI64Encoder()], ['status', getStatusEncoder()], ['bump', getU8Encoder()]]);
}



export function getPaymentDecoder(): FixedSizeDecoder<Payment> {
  return getStructDecoder([['discriminator', getU8Decoder()], ['orderId', getU32Decoder()], ['amount', getU64Decoder()], ['createdAt', getI64Decoder()], ['status', getStatusDecoder()], ['bump', getU8Decoder()]]);
}




export function getPaymentCodec(): FixedSizeCodec<PaymentArgs, Payment> {
  return combineCodec(getPaymentEncoder(), getPaymentDecoder());
}

export function decodePayment<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<Payment, TAddress>;
export function decodePayment<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<Payment, TAddress>;
export function decodePayment<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>): Account<Payment, TAddress> | MaybeAccount<Payment, TAddress> {
  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getPaymentDecoder());
}

export async function fetchPayment<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<Payment, TAddress>> {
  const maybeAccount = await fetchMaybePayment(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybePayment<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<Payment, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodePayment(maybeAccount);
}

export async function fetchAllPayment(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<Payment>[]> {
  const maybeAccounts = await fetchAllMaybePayment(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybePayment(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<Payment>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePayment(maybeAccount));
}

export function getPaymentSize(): number {
  return 23;
}


