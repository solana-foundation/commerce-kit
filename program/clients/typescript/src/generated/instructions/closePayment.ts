/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { combineCodec, getAddressEncoder, getProgramDerivedAddress, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, getUtf8Encoder, transformEncoder, type AccountMeta, type AccountSignerMeta, type Address, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type Instruction, type InstructionWithAccounts, type InstructionWithData, type ReadonlyAccount, type ReadonlySignerAccount, type ReadonlyUint8Array, type TransactionSigner, type WritableAccount, type WritableSignerAccount } from '@solana/kit';
import { COMMERCE_PROGRAM_PROGRAM_ADDRESS } from '../programs';
import { expectAddress, getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const CLOSE_PAYMENT_DISCRIMINATOR = 10;

export function getClosePaymentDiscriminatorBytes() { return getU8Encoder().encode(CLOSE_PAYMENT_DISCRIMINATOR); }

export type ClosePaymentInstruction<
  TProgram extends string = typeof COMMERCE_PROGRAM_PROGRAM_ADDRESS,
      TAccountPayer extends string | AccountMeta<string> = string, TAccountPayment extends string | AccountMeta<string> = string, TAccountOperatorAuthority extends string | AccountMeta<string> = string, TAccountOperator extends string | AccountMeta<string> = string, TAccountMerchant extends string | AccountMeta<string> = string, TAccountBuyer extends string | AccountMeta<string> = string, TAccountMerchantOperatorConfig extends string | AccountMeta<string> = string, TAccountMint extends string | AccountMeta<string> = string, TAccountSystemProgram extends string | AccountMeta<string> = "11111111111111111111111111111111",
    TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram>
      & InstructionWithData<ReadonlyUint8Array>
        & InstructionWithAccounts<[TAccountPayer extends string ? WritableSignerAccount<TAccountPayer> & AccountSignerMeta<TAccountPayer> : TAccountPayer, TAccountPayment extends string ? WritableAccount<TAccountPayment> : TAccountPayment, TAccountOperatorAuthority extends string ? ReadonlySignerAccount<TAccountOperatorAuthority> & AccountSignerMeta<TAccountOperatorAuthority> : TAccountOperatorAuthority, TAccountOperator extends string ? ReadonlyAccount<TAccountOperator> : TAccountOperator, TAccountMerchant extends string ? ReadonlyAccount<TAccountMerchant> : TAccountMerchant, TAccountBuyer extends string ? ReadonlyAccount<TAccountBuyer> : TAccountBuyer, TAccountMerchantOperatorConfig extends string ? ReadonlyAccount<TAccountMerchantOperatorConfig> : TAccountMerchantOperatorConfig, TAccountMint extends string ? ReadonlyAccount<TAccountMint> : TAccountMint, TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram, ...TRemainingAccounts]>
  ;



export type ClosePaymentInstructionData = { discriminator: number;  };

export type ClosePaymentInstructionDataArgs = {  };




export function getClosePaymentInstructionDataEncoder(): FixedSizeEncoder<ClosePaymentInstructionDataArgs> {
  return transformEncoder(getStructEncoder([['discriminator', getU8Encoder()]]), (value) => ({ ...value, discriminator: CLOSE_PAYMENT_DISCRIMINATOR }));
}



export function getClosePaymentInstructionDataDecoder(): FixedSizeDecoder<ClosePaymentInstructionData> {
  return getStructDecoder([['discriminator', getU8Decoder()]]);
}




export function getClosePaymentInstructionDataCodec(): FixedSizeCodec<ClosePaymentInstructionDataArgs, ClosePaymentInstructionData> {
  return combineCodec(getClosePaymentInstructionDataEncoder(), getClosePaymentInstructionDataDecoder());
}



export type ClosePaymentAsyncInput<TAccountPayer extends string = string,
  TAccountPayment extends string = string,
  TAccountOperatorAuthority extends string = string,
  TAccountOperator extends string = string,
  TAccountMerchant extends string = string,
  TAccountBuyer extends string = string,
  TAccountMerchantOperatorConfig extends string = string,
  TAccountMint extends string = string,
  TAccountSystemProgram extends string = string,
  >
=  {
  payer: TransactionSigner<TAccountPayer>;
/** Payment PDA to close */
payment: Address<TAccountPayment>;
operatorAuthority: TransactionSigner<TAccountOperatorAuthority>;
/** Operator PDA */
operator?: Address<TAccountOperator>;
/** Merchant PDA */
merchant: Address<TAccountMerchant>;
/** Buyer account */
buyer: Address<TAccountBuyer>;
/** Merchant Operator Config PDA */
merchantOperatorConfig: Address<TAccountMerchantOperatorConfig>;
/** Token mint */
mint: Address<TAccountMint>;
systemProgram?: Address<TAccountSystemProgram>;
}


export async function getClosePaymentInstructionAsync<TAccountPayer extends string, TAccountPayment extends string, TAccountOperatorAuthority extends string, TAccountOperator extends string, TAccountMerchant extends string, TAccountBuyer extends string, TAccountMerchantOperatorConfig extends string, TAccountMint extends string, TAccountSystemProgram extends string, TProgramAddress extends Address = typeof COMMERCE_PROGRAM_PROGRAM_ADDRESS>(input: ClosePaymentAsyncInput<TAccountPayer, TAccountPayment, TAccountOperatorAuthority, TAccountOperator, TAccountMerchant, TAccountBuyer, TAccountMerchantOperatorConfig, TAccountMint, TAccountSystemProgram>, config?: { programAddress?: TProgramAddress } ): Promise<ClosePaymentInstruction<TProgramAddress, TAccountPayer, TAccountPayment, TAccountOperatorAuthority, TAccountOperator, TAccountMerchant, TAccountBuyer, TAccountMerchantOperatorConfig, TAccountMint, TAccountSystemProgram>> {
  // Program address.
  const programAddress = config?.programAddress ?? COMMERCE_PROGRAM_PROGRAM_ADDRESS;

      // Original accounts.
    const originalAccounts = {
              payer: { value: input.payer ?? null, isWritable: true },
              payment: { value: input.payment ?? null, isWritable: true },
              operatorAuthority: { value: input.operatorAuthority ?? null, isWritable: false },
              operator: { value: input.operator ?? null, isWritable: false },
              merchant: { value: input.merchant ?? null, isWritable: false },
              buyer: { value: input.buyer ?? null, isWritable: false },
              merchantOperatorConfig: { value: input.merchantOperatorConfig ?? null, isWritable: false },
              mint: { value: input.mint ?? null, isWritable: false },
              systemProgram: { value: input.systemProgram ?? null, isWritable: false },
          };
    const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;
  
  
  
  // Resolve default values.
if (!accounts.operator.value) {
accounts.operator.value = await getProgramDerivedAddress({ programAddress: 'commkU28d52cwo2Ma3Marxz4Qr9REtfJtuUfqnDnbhT' as Address<'commkU28d52cwo2Ma3Marxz4Qr9REtfJtuUfqnDnbhT'>, seeds: [getUtf8Encoder().encode("operator"), getAddressEncoder().encode(expectAddress(accounts.operatorAuthority.value))] });
}
if (!accounts.systemProgram.value) {
accounts.systemProgram.value = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
}





      const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {accounts: [
                  getAccountMeta(accounts.payer),
                  getAccountMeta(accounts.payment),
                  getAccountMeta(accounts.operatorAuthority),
                  getAccountMeta(accounts.operator),
                  getAccountMeta(accounts.merchant),
                  getAccountMeta(accounts.buyer),
                  getAccountMeta(accounts.merchantOperatorConfig),
                  getAccountMeta(accounts.mint),
                  getAccountMeta(accounts.systemProgram),
                      ]      ,    programAddress,
          data: getClosePaymentInstructionDataEncoder().encode({}),
      } as ClosePaymentInstruction<TProgramAddress, TAccountPayer, TAccountPayment, TAccountOperatorAuthority, TAccountOperator, TAccountMerchant, TAccountBuyer, TAccountMerchantOperatorConfig, TAccountMint, TAccountSystemProgram>;

      return instruction;
  }


export type ClosePaymentInput<TAccountPayer extends string = string,
  TAccountPayment extends string = string,
  TAccountOperatorAuthority extends string = string,
  TAccountOperator extends string = string,
  TAccountMerchant extends string = string,
  TAccountBuyer extends string = string,
  TAccountMerchantOperatorConfig extends string = string,
  TAccountMint extends string = string,
  TAccountSystemProgram extends string = string,
  >
=  {
  payer: TransactionSigner<TAccountPayer>;
/** Payment PDA to close */
payment: Address<TAccountPayment>;
operatorAuthority: TransactionSigner<TAccountOperatorAuthority>;
/** Operator PDA */
operator: Address<TAccountOperator>;
/** Merchant PDA */
merchant: Address<TAccountMerchant>;
/** Buyer account */
buyer: Address<TAccountBuyer>;
/** Merchant Operator Config PDA */
merchantOperatorConfig: Address<TAccountMerchantOperatorConfig>;
/** Token mint */
mint: Address<TAccountMint>;
systemProgram?: Address<TAccountSystemProgram>;
}


export  function getClosePaymentInstruction<TAccountPayer extends string, TAccountPayment extends string, TAccountOperatorAuthority extends string, TAccountOperator extends string, TAccountMerchant extends string, TAccountBuyer extends string, TAccountMerchantOperatorConfig extends string, TAccountMint extends string, TAccountSystemProgram extends string, TProgramAddress extends Address = typeof COMMERCE_PROGRAM_PROGRAM_ADDRESS>(input: ClosePaymentInput<TAccountPayer, TAccountPayment, TAccountOperatorAuthority, TAccountOperator, TAccountMerchant, TAccountBuyer, TAccountMerchantOperatorConfig, TAccountMint, TAccountSystemProgram>, config?: { programAddress?: TProgramAddress } ): ClosePaymentInstruction<TProgramAddress, TAccountPayer, TAccountPayment, TAccountOperatorAuthority, TAccountOperator, TAccountMerchant, TAccountBuyer, TAccountMerchantOperatorConfig, TAccountMint, TAccountSystemProgram> {
  // Program address.
  const programAddress = config?.programAddress ?? COMMERCE_PROGRAM_PROGRAM_ADDRESS;

      // Original accounts.
    const originalAccounts = {
              payer: { value: input.payer ?? null, isWritable: true },
              payment: { value: input.payment ?? null, isWritable: true },
              operatorAuthority: { value: input.operatorAuthority ?? null, isWritable: false },
              operator: { value: input.operator ?? null, isWritable: false },
              merchant: { value: input.merchant ?? null, isWritable: false },
              buyer: { value: input.buyer ?? null, isWritable: false },
              merchantOperatorConfig: { value: input.merchantOperatorConfig ?? null, isWritable: false },
              mint: { value: input.mint ?? null, isWritable: false },
              systemProgram: { value: input.systemProgram ?? null, isWritable: false },
          };
    const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;
  
  
  
  // Resolve default values.
if (!accounts.systemProgram.value) {
accounts.systemProgram.value = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
}





      const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {accounts: [
                  getAccountMeta(accounts.payer),
                  getAccountMeta(accounts.payment),
                  getAccountMeta(accounts.operatorAuthority),
                  getAccountMeta(accounts.operator),
                  getAccountMeta(accounts.merchant),
                  getAccountMeta(accounts.buyer),
                  getAccountMeta(accounts.merchantOperatorConfig),
                  getAccountMeta(accounts.mint),
                  getAccountMeta(accounts.systemProgram),
                      ]      ,    programAddress,
          data: getClosePaymentInstructionDataEncoder().encode({}),
      } as ClosePaymentInstruction<TProgramAddress, TAccountPayer, TAccountPayment, TAccountOperatorAuthority, TAccountOperator, TAccountMerchant, TAccountBuyer, TAccountMerchantOperatorConfig, TAccountMint, TAccountSystemProgram>;

      return instruction;
  }


export type ParsedClosePaymentInstruction<
  TProgram extends string = typeof COMMERCE_PROGRAM_PROGRAM_ADDRESS,
      TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
  > = {
  programAddress: Address<TProgram>;
      accounts: {
                      payer: TAccountMetas[0],
                        /** Payment PDA to close */
                payment: TAccountMetas[1],
                      operatorAuthority: TAccountMetas[2],
                        /** Operator PDA */
                operator: TAccountMetas[3],
                        /** Merchant PDA */
                merchant: TAccountMetas[4],
                        /** Buyer account */
                buyer: TAccountMetas[5],
                        /** Merchant Operator Config PDA */
                merchantOperatorConfig: TAccountMetas[6],
                        /** Token mint */
                mint: TAccountMetas[7],
                      systemProgram: TAccountMetas[8],
          };
        data: ClosePaymentInstructionData;
  };

export function parseClosePaymentInstruction<
  TProgram extends string,
      TAccountMetas extends readonly AccountMeta[],
  >(
  instruction: Instruction<TProgram>
          & InstructionWithAccounts<TAccountMetas>
              & InstructionWithData<ReadonlyUint8Array>
    ): ParsedClosePaymentInstruction<TProgram , TAccountMetas> {
      if (instruction.accounts.length < 9) {
      // TODO: Coded error.
      throw new Error('Not enough accounts');
    }
    let accountIndex = 0;
    const getNextAccount = () => {
      const accountMeta = instruction.accounts![accountIndex]!;
      accountIndex += 1;
      return accountMeta;
    }
        return {
    programAddress: instruction.programAddress,
          accounts: {
                              payer: getNextAccount(),
                                        payment: getNextAccount(),
                                        operatorAuthority: getNextAccount(),
                                        operator: getNextAccount(),
                                        merchant: getNextAccount(),
                                        buyer: getNextAccount(),
                                        merchantOperatorConfig: getNextAccount(),
                                        mint: getNextAccount(),
                                        systemProgram: getNextAccount(),
                        },
              data: getClosePaymentInstructionDataDecoder().decode(instruction.data),
      };
}

