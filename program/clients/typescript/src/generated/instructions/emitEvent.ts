/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { combineCodec, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, type AccountMeta, type AccountSignerMeta, type Address, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type Instruction, type InstructionWithAccounts, type InstructionWithData, type ReadonlySignerAccount, type ReadonlyUint8Array, type TransactionSigner } from '@solana/kit';
import { COMMERCE_PROGRAM_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const EMIT_EVENT_DISCRIMINATOR = 228;

export function getEmitEventDiscriminatorBytes() { return getU8Encoder().encode(EMIT_EVENT_DISCRIMINATOR); }

export type EmitEventInstruction<
  TProgram extends string = typeof COMMERCE_PROGRAM_PROGRAM_ADDRESS,
      TAccountEventAuthority extends string | AccountMeta<string> = "3VSJP7faqLk6MbCaNtMYc2Y8S8hMXRsZ5cBcwh1fjMH1",
    TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram>
      & InstructionWithData<ReadonlyUint8Array>
        & InstructionWithAccounts<[TAccountEventAuthority extends string ? ReadonlySignerAccount<TAccountEventAuthority> & AccountSignerMeta<TAccountEventAuthority> : TAccountEventAuthority, ...TRemainingAccounts]>
  ;



export type EmitEventInstructionData = { discriminator: number;  };

export type EmitEventInstructionDataArgs = {  };




export function getEmitEventInstructionDataEncoder(): FixedSizeEncoder<EmitEventInstructionDataArgs> {
  return transformEncoder(getStructEncoder([['discriminator', getU8Encoder()]]), (value) => ({ ...value, discriminator: EMIT_EVENT_DISCRIMINATOR }));
}



export function getEmitEventInstructionDataDecoder(): FixedSizeDecoder<EmitEventInstructionData> {
  return getStructDecoder([['discriminator', getU8Decoder()]]);
}




export function getEmitEventInstructionDataCodec(): FixedSizeCodec<EmitEventInstructionDataArgs, EmitEventInstructionData> {
  return combineCodec(getEmitEventInstructionDataEncoder(), getEmitEventInstructionDataDecoder());
}




export type EmitEventInput<TAccountEventAuthority extends string = string,
  >
=  {
  eventAuthority?: TransactionSigner<TAccountEventAuthority>;
}


export  function getEmitEventInstruction<TAccountEventAuthority extends string, TProgramAddress extends Address = typeof COMMERCE_PROGRAM_PROGRAM_ADDRESS>(input: EmitEventInput<TAccountEventAuthority>, config?: { programAddress?: TProgramAddress } ): EmitEventInstruction<TProgramAddress, TAccountEventAuthority> {
  // Program address.
  const programAddress = config?.programAddress ?? COMMERCE_PROGRAM_PROGRAM_ADDRESS;

      // Original accounts.
    const originalAccounts = {
              eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
          };
    const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;
  
  
  
  // Resolve default values.
if (!accounts.eventAuthority.value) {
accounts.eventAuthority.value = '3VSJP7faqLk6MbCaNtMYc2Y8S8hMXRsZ5cBcwh1fjMH1' as Address<'3VSJP7faqLk6MbCaNtMYc2Y8S8hMXRsZ5cBcwh1fjMH1'>;
}





      const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {accounts: [
                  getAccountMeta(accounts.eventAuthority),
                      ]      ,    programAddress,
          data: getEmitEventInstructionDataEncoder().encode({}),
      } as EmitEventInstruction<TProgramAddress, TAccountEventAuthority>;

      return instruction;
  }


export type ParsedEmitEventInstruction<
  TProgram extends string = typeof COMMERCE_PROGRAM_PROGRAM_ADDRESS,
      TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
  > = {
  programAddress: Address<TProgram>;
      accounts: {
                      eventAuthority: TAccountMetas[0],
          };
        data: EmitEventInstructionData;
  };

export function parseEmitEventInstruction<
  TProgram extends string,
      TAccountMetas extends readonly AccountMeta[],
  >(
  instruction: Instruction<TProgram>
          & InstructionWithAccounts<TAccountMetas>
              & InstructionWithData<ReadonlyUint8Array>
    ): ParsedEmitEventInstruction<TProgram , TAccountMetas> {
      if (instruction.accounts.length < 1) {
      // TODO: Coded error.
      throw new Error('Not enough accounts');
    }
    let accountIndex = 0;
    const getNextAccount = () => {
      const accountMeta = instruction.accounts![accountIndex]!;
      accountIndex += 1;
      return accountMeta;
    }
        return {
    programAddress: instruction.programAddress,
          accounts: {
                              eventAuthority: getNextAccount(),
                        },
              data: getEmitEventInstructionDataDecoder().decode(instruction.data),
      };
}

